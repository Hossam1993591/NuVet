using Microsoft.Extensions.Logging;
using Moq;
using NuVet.Core.Models;
using NuVet.Core.Services;
using NuVet.Core.Services.Implementation;
using FluentAssertions;
using Semver;

namespace NuVet.Tests.Services;

public class VulnerabilityScannerImplementationTests
{
    private readonly Mock<IVulnerabilityService> _mockVulnerabilityService;
    private readonly Mock<IDependencyAnalyzer> _mockDependencyAnalyzer;
    private readonly Mock<ILogger<VulnerabilityScanner>> _mockLogger;
    private readonly VulnerabilityScanner _scanner;

    public VulnerabilityScannerImplementationTests()
    {
        _mockVulnerabilityService = new Mock<IVulnerabilityService>();
        _mockDependencyAnalyzer = new Mock<IDependencyAnalyzer>();
        _mockLogger = new Mock<ILogger<VulnerabilityScanner>>();
        _scanner = new VulnerabilityScanner(_mockDependencyAnalyzer.Object, _mockVulnerabilityService.Object, _mockLogger.Object);
    }

    [Fact]
    public async Task ScanAsync_WithValidSolutionPath_ReturnsCorrectScanResult()
    {
        // Arrange
        var solutionPath = "/test/TestSolution.sln";
        var dependencyGraph = CreateTestDependencyGraph();
        var vulnerabilities = CreateTestVulnerabilities();

        _mockDependencyAnalyzer
            .Setup(x => x.AnalyzeAsync(solutionPath, It.IsAny<CancellationToken>()))
            .ReturnsAsync(dependencyGraph);

        _mockVulnerabilityService
            .Setup(x => x.GetVulnerabilitiesAsync("VulnerablePackage", It.IsAny<CancellationToken>()))
            .ReturnsAsync(vulnerabilities);

        _mockVulnerabilityService
            .Setup(x => x.GetVulnerabilitiesAsync("SafePackage", It.IsAny<CancellationToken>()))
            .ReturnsAsync(new List<Vulnerability>());

        // Act
        var result = await _scanner.ScanAsync(solutionPath);

        // Assert
        result.Should().NotBeNull();
        result.SolutionPath.Should().Be(solutionPath);
        result.ScannedProjects.Should().HaveCount(2);
        result.VulnerablePackages.Should().HaveCount(1);
        result.HasVulnerabilities.Should().BeTrue();
        
        var vulnerablePackage = result.VulnerablePackages.First();
        vulnerablePackage.Package.Id.Should().Be("VulnerablePackage");
        vulnerablePackage.Vulnerabilities.Should().HaveCount(2);
        vulnerablePackage.HighestSeverity.Should().Be(VulnerabilitySeverity.Critical);
    }

    [Fact]
    public async Task ScanAsync_WithScanOptions_AppliesFilters()
    {
        // Arrange
        var solutionPath = "/test/TestSolution.sln";
        var options = new ScanOptions
        {
            MinimumSeverity = VulnerabilitySeverity.Critical,
            ExcludePackages = new List<string> { "ExcludedPackage" }
        };
        
        var dependencyGraph = CreateComplexDependencyGraph();
        SetupComplexVulnerabilities();

        _mockDependencyAnalyzer
            .Setup(x => x.AnalyzeAsync(solutionPath, It.IsAny<CancellationToken>()))
            .ReturnsAsync(dependencyGraph);

        // Act
        var result = await _scanner.ScanAsync(solutionPath, options);

        // Assert
        result.Should().NotBeNull();
        result.VulnerablePackages.Should().OnlyContain(vp => vp.HighestSeverity >= VulnerabilitySeverity.Critical);
        result.VulnerablePackages.Should().NotContain(vp => vp.Package.Id == "ExcludedPackage");
    }

    [Fact]
    public async Task ScanAsync_WithEmptyDependencyGraph_ReturnsEmptyScanResult()
    {
        // Arrange
        var solutionPath = "/test/EmptySolution.sln";
        var emptyGraph = new DependencyGraph
        {
            RootPath = solutionPath,
            Projects = new List<ProjectInfo>(),
            AllPackages = new List<PackageReference>()
        };

        _mockDependencyAnalyzer
            .Setup(x => x.AnalyzeAsync(solutionPath, It.IsAny<CancellationToken>()))
            .ReturnsAsync(emptyGraph);

        // Act
        var result = await _scanner.ScanAsync(solutionPath);

        // Assert
        result.Should().NotBeNull();
        result.SolutionPath.Should().Be(solutionPath);
        result.ScannedProjects.Should().BeEmpty();
        result.VulnerablePackages.Should().BeEmpty();
        result.HasVulnerabilities.Should().BeFalse();
        result.HasCriticalVulnerabilities.Should().BeFalse();
    }

        [Fact]
    public async Task ScanAsync_WhenDependencyAnalyzerThrows_ReturnsEmptyScanResult()
    {
        // Arrange
        var mockAnalyzer = new Mock<IDependencyAnalyzer>();
        var mockVulnerabilityService = new Mock<IVulnerabilityService>();
        var mockLogger = new Mock<ILogger<VulnerabilityScanner>>();
        
        mockAnalyzer.Setup(x => x.AnalyzeAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
                   .ThrowsAsync(new FileNotFoundException("Project file not found"));
        
        var scanner = new VulnerabilityScanner(mockAnalyzer.Object, mockVulnerabilityService.Object, mockLogger.Object);
        
        // Act
        var result = await scanner.ScanAsync("/invalid/path", cancellationToken: CancellationToken.None);
        
        // Assert
        result.Should().NotBeNull();
        result.VulnerablePackages.Should().BeEmpty();
        result.ScannedProjects.Should().BeEmpty();
        result.SolutionPath.Should().Be("/invalid/path");
    }

    [Fact]
    public async Task ScanPackagesAsync_WithVulnerablePackages_ReturnsCorrectResults()
    {
        // Arrange
        var packages = new List<PackageReference>
        {
            CreatePackageReference("TestPackage1", "1.0.0"),
            CreatePackageReference("TestPackage2", "2.0.0"),
            CreatePackageReference("SafePackage", "3.0.0")
        };

        var vulnerabilities1 = new List<Vulnerability>
        {
            CreateVulnerability("GHSA-001", "TestPackage1", "1.1.0", VulnerabilitySeverity.High)
        };

        var vulnerabilities2 = new List<Vulnerability>
        {
            CreateVulnerability("GHSA-002", "TestPackage2", "2.1.0", VulnerabilitySeverity.Critical)
        };

        _mockVulnerabilityService
            .Setup(x => x.GetVulnerabilitiesAsync("TestPackage1", It.IsAny<CancellationToken>()))
            .ReturnsAsync(vulnerabilities1);

        _mockVulnerabilityService
            .Setup(x => x.GetVulnerabilitiesAsync("TestPackage2", It.IsAny<CancellationToken>()))
            .ReturnsAsync(vulnerabilities2);

        _mockVulnerabilityService
            .Setup(x => x.GetVulnerabilitiesAsync("SafePackage", It.IsAny<CancellationToken>()))
            .ReturnsAsync(new List<Vulnerability>());

        // Act
        var result = await _scanner.ScanPackagesAsync(packages);

        // Assert
        result.Should().HaveCount(2);
        result.Should().Contain(vp => vp.Package.Id == "TestPackage1");
        result.Should().Contain(vp => vp.Package.Id == "TestPackage2");
        result.Should().NotContain(vp => vp.Package.Id == "SafePackage");
        
        var criticalPackage = result.First(vp => vp.Package.Id == "TestPackage2");
        criticalPackage.HighestSeverity.Should().Be(VulnerabilitySeverity.Critical);
    }

    [Fact]
    public async Task ScanPackagesAsync_WithMultiplePackages_ReturnsAllVulnerablePackages()
    {
        // Arrange
        var packages = new List<PackageReference>
        {
            CreatePackageReference("HighVulnPackage", "1.0.0"),
            CreatePackageReference("ModerateVulnPackage", "1.0.0"),
            CreatePackageReference("LowVulnPackage", "1.0.0")
        };

        SetupVulnerabilitiesWithDifferentSeverities();

        // Act
        var result = await _scanner.ScanPackagesAsync(packages);

        // Assert - Since ScanPackagesAsync doesn't apply options filtering, check raw results
        result.Should().HaveCount(3); // All three packages have vulnerabilities
    }

    [Fact]
    public async Task ScanPackagesAsync_WhenVulnerabilityServiceThrows_HandlesGracefully()
    {
        // Arrange
        var packages = new List<PackageReference>
        {
            CreatePackageReference("ProblematicPackage", "1.0.0"),
            CreatePackageReference("GoodPackage", "1.0.0")
        };

        _mockVulnerabilityService
            .Setup(x => x.GetVulnerabilitiesAsync("ProblematicPackage", It.IsAny<CancellationToken>()))
            .ThrowsAsync(new HttpRequestException("Network error"));

        _mockVulnerabilityService
            .Setup(x => x.GetVulnerabilitiesAsync("GoodPackage", It.IsAny<CancellationToken>()))
            .ReturnsAsync(new List<Vulnerability>());

        // Act
        var result = await _scanner.ScanPackagesAsync(packages);

        // Assert
        result.Should().BeEmpty(); // No vulnerable packages since error was handled
        
        // Verify logging of error
        _mockLogger.Verify(
            x => x.Log(
                LogLevel.Error,
                It.IsAny<EventId>(),
                It.Is<It.IsAnyType>((v, t) => v.ToString().Contains("ProblematicPackage")),
                It.IsAny<Exception>(),
                It.IsAny<Func<It.IsAnyType, Exception?, string>>()),
            Times.Once);
    }

    [Fact] 
    public async Task ScanPackagesAsync_WithEmptyPackageList_ReturnsEmptyResult()
    {
        // Arrange
        var emptyPackages = new List<PackageReference>();

        // Act
        var result = await _scanner.ScanPackagesAsync(emptyPackages);

        // Assert
        result.Should().BeEmpty();
        
        // Verify no service calls were made
        _mockVulnerabilityService.Verify(
            x => x.GetVulnerabilitiesAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()),
            Times.Never);
    }

    [Fact]
    public async Task ScanPackagesAsync_WithCancellationToken_PropagatesToken()
    {
        // Arrange
        var packages = new List<PackageReference>
        {
            CreatePackageReference("TestPackage", "1.0.0")
        };
        
        using var cancellationTokenSource = new CancellationTokenSource();
        cancellationTokenSource.Cancel(); // Cancel immediately
        var cancellationToken = cancellationTokenSource.Token;

        // Act & Assert - Check that cancellation is handled
        // Note: The implementation may handle cancellation gracefully, so check behavior
        var result = await _scanner.ScanPackagesAsync(packages, cancellationToken);
        
        // If cancellation is handled gracefully, result might be empty
        result.Should().NotBeNull();
    }

    private static DependencyGraph CreateTestDependencyGraph()
    {
        return new DependencyGraph
        {
            RootPath = "/test/TestSolution.sln",
            Projects = new List<ProjectInfo>
            {
                new ProjectInfo
                {
                    Name = "Project1",
                    Path = "/test/Project1/Project1.csproj",
                    TargetFramework = "net8.0",
                    Type = ProjectType.ConsoleApplication
                },
                new ProjectInfo
                {
                    Name = "Project2",
                    Path = "/test/Project2/Project2.csproj",
                    TargetFramework = "net8.0",
                    Type = ProjectType.ClassLibrary
                }
            },
            AllPackages = new List<PackageReference>
            {
                CreatePackageReference("VulnerablePackage", "1.0.0", "/test/Project1/Project1.csproj"),
                CreatePackageReference("SafePackage", "2.0.0", "/test/Project2/Project2.csproj")
            }
        };
    }

    private static DependencyGraph CreateComplexDependencyGraph()
    {
        return new DependencyGraph
        {
            RootPath = "/test/ComplexSolution.sln",
            Projects = new List<ProjectInfo>
            {
                new ProjectInfo
                {
                    Name = "MainProject",
                    Path = "/test/MainProject/MainProject.csproj",
                    TargetFramework = "net8.0",
                    Type = ProjectType.ConsoleApplication
                }
            },
            AllPackages = new List<PackageReference>
            {
                CreatePackageReference("CriticalVulnPackage", "1.0.0"),
                CreatePackageReference("HighVulnPackage", "1.0.0"),
                CreatePackageReference("ModerateVulnPackage", "1.0.0"),
                CreatePackageReference("ExcludedPackage", "1.0.0"),
                CreatePackageReference("SafePackage", "1.0.0")
            }
        };
    }

    private static PackageReference CreatePackageReference(string id, string version, string projectPath = "/test/project.csproj")
    {
        return new PackageReference
        {
            Id = id,
            Version = SemVersion.Parse(version, SemVersionStyles.Strict),
            ProjectPath = projectPath
        };
    }

    private static List<Vulnerability> CreateTestVulnerabilities()
    {
        return new List<Vulnerability>
        {
            CreateVulnerability("GHSA-001", "VulnerablePackage", "1.1.0", VulnerabilitySeverity.Critical),
            CreateVulnerability("GHSA-002", "VulnerablePackage", "1.0.5", VulnerabilitySeverity.High)
        };
    }

    private void SetupComplexVulnerabilities()
    {
        _mockVulnerabilityService
            .Setup(x => x.GetVulnerabilitiesAsync("CriticalVulnPackage", It.IsAny<CancellationToken>()))
            .ReturnsAsync(new List<Vulnerability> 
            { 
                CreateVulnerability("GHSA-003", "CriticalVulnPackage", "1.1.0", VulnerabilitySeverity.Critical) 
            });

        _mockVulnerabilityService
            .Setup(x => x.GetVulnerabilitiesAsync("HighVulnPackage", It.IsAny<CancellationToken>()))
            .ReturnsAsync(new List<Vulnerability> 
            { 
                CreateVulnerability("GHSA-004", "HighVulnPackage", "1.1.0", VulnerabilitySeverity.High) 
            });

        _mockVulnerabilityService
            .Setup(x => x.GetVulnerabilitiesAsync("ModerateVulnPackage", It.IsAny<CancellationToken>()))
            .ReturnsAsync(new List<Vulnerability> 
            { 
                CreateVulnerability("GHSA-005", "ModerateVulnPackage", "1.1.0", VulnerabilitySeverity.Moderate) 
            });

        _mockVulnerabilityService
            .Setup(x => x.GetVulnerabilitiesAsync("ExcludedPackage", It.IsAny<CancellationToken>()))
            .ReturnsAsync(new List<Vulnerability> 
            { 
                CreateVulnerability("GHSA-006", "ExcludedPackage", "1.1.0", VulnerabilitySeverity.Critical) 
            });

        _mockVulnerabilityService
            .Setup(x => x.GetVulnerabilitiesAsync("SafePackage", It.IsAny<CancellationToken>()))
            .ReturnsAsync(new List<Vulnerability>());
    }

    private void SetupVulnerabilitiesWithDifferentSeverities()
    {
        _mockVulnerabilityService
            .Setup(x => x.GetVulnerabilitiesAsync("HighVulnPackage", It.IsAny<CancellationToken>()))
            .ReturnsAsync(new List<Vulnerability> 
            { 
                CreateVulnerability("GHSA-007", "HighVulnPackage", "1.1.0", VulnerabilitySeverity.High) 
            });

        _mockVulnerabilityService
            .Setup(x => x.GetVulnerabilitiesAsync("ModerateVulnPackage", It.IsAny<CancellationToken>()))
            .ReturnsAsync(new List<Vulnerability> 
            { 
                CreateVulnerability("GHSA-008", "ModerateVulnPackage", "1.1.0", VulnerabilitySeverity.Moderate) 
            });

        _mockVulnerabilityService
            .Setup(x => x.GetVulnerabilitiesAsync("LowVulnPackage", It.IsAny<CancellationToken>()))
            .ReturnsAsync(new List<Vulnerability> 
            { 
                CreateVulnerability("GHSA-009", "LowVulnPackage", "1.1.0", VulnerabilitySeverity.Low) 
            });
    }

    private static Vulnerability CreateVulnerability(string id, string packageId, string patchedVersion, VulnerabilitySeverity severity = VulnerabilitySeverity.High)
    {
        return new Vulnerability
        {
            Id = id,
            Title = $"Test Vulnerability {id}",
            Description = $"Test vulnerability for {packageId}",
            Severity = severity,
            PackageId = packageId,
            AffectedVersions = new List<SemVersion> { SemVersion.Parse("1.0.0", SemVersionStyles.Strict) },
            PatchedVersions = new List<SemVersion> { SemVersion.Parse(patchedVersion, SemVersionStyles.Strict) },
            AdvisoryUrl = new Uri($"https://example.com/advisory/{id}"),
            PublishedAt = DateTime.UtcNow.AddDays(-10),
            UpdatedAt = DateTime.UtcNow.AddDays(-5),
            CveIds = new List<string> { $"CVE-2023-{id}" },
            References = new List<string> { $"https://example.com/ref/{id}" }
        };
    }
}