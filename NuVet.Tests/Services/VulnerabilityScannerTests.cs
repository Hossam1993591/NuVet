using Microsoft.Extensions.Logging;
using Moq;
using NuVet.Core.Models;
using NuVet.Core.Services;
using NuVet.Core.Services.Implementation;
using FluentAssertions;
using Semver;

namespace NuVet.Tests.Services;

public class VulnerabilityScannerTests
{
    private readonly Mock<IDependencyAnalyzer> _mockDependencyAnalyzer;
    private readonly Mock<IVulnerabilityService> _mockVulnerabilityService;
    private readonly Mock<ILogger<VulnerabilityScanner>> _mockLogger;
    private readonly VulnerabilityScanner _scanner;

    public VulnerabilityScannerTests()
    {
        _mockDependencyAnalyzer = new Mock<IDependencyAnalyzer>();
        _mockVulnerabilityService = new Mock<IVulnerabilityService>();
        _mockLogger = new Mock<ILogger<VulnerabilityScanner>>();
        _scanner = new VulnerabilityScanner(_mockDependencyAnalyzer.Object, _mockVulnerabilityService.Object, _mockLogger.Object);
    }

    [Fact]
    public async Task ScanAsync_WithValidPath_ReturnsCompleteScanResult()
    {
        // Arrange
        var solutionPath = "/test/solution.sln";
        var dependencyGraph = CreateTestDependencyGraph();
        var vulnerabilities = CreateTestVulnerabilities();

        _mockDependencyAnalyzer
            .Setup(x => x.AnalyzeAsync(solutionPath, It.IsAny<CancellationToken>()))
            .ReturnsAsync(dependencyGraph);

        _mockVulnerabilityService
            .Setup(x => x.GetVulnerabilitiesAsync(It.IsAny<IEnumerable<string>>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(vulnerabilities);

        // Act
        var result = await _scanner.ScanAsync(solutionPath);

        // Assert
        result.Should().NotBeNull();
        result.SolutionPath.Should().Be("/test"); // This comes from dependencyGraph.RootPath via ScanDependencyGraphAsync
        result.ScannedProjects.Should().HaveCount(dependencyGraph.Projects.Count);
        result.ScanDuration.Should().BeGreaterThan(TimeSpan.Zero);
        
        // Verify dependencies were analyzed
        _mockDependencyAnalyzer.Verify(
            x => x.AnalyzeAsync(solutionPath, It.IsAny<CancellationToken>()),
            Times.Once);
    }

    #region Helper Methods

    private static DependencyGraph CreateTestDependencyGraph()
    {
        var projects = new List<ProjectInfo>
        {
            new ProjectInfo
            {
                Name = "TestProject",
                Path = "/test/project.csproj",
                TargetFramework = "net8.0",
                Type = ProjectType.ConsoleApplication
            }
        };

        var packages = new List<PackageReference>
        {
            CreatePackageReference("VulnerablePackage", "1.0.0"),
            CreatePackageReference("SafePackage", "2.0.0")
        };

        return new DependencyGraph
        {
            RootPath = "/test",
            Projects = projects,
            AllPackages = packages
        };
    }

    private static Dictionary<string, List<Vulnerability>> CreateTestVulnerabilities()
    {
        return new Dictionary<string, List<Vulnerability>>
        {
            {
                "VulnerablePackage",
                new List<Vulnerability>
                {
                    CreateVulnerability("GHSA-001", VulnerabilitySeverity.High),
                    CreateVulnerability("GHSA-002", VulnerabilitySeverity.Moderate)
                }
            }
        };
    }

    private static PackageReference CreatePackageReference(string id, string version)
    {
        return new PackageReference
        {
            Id = id,
            Version = SemVersion.Parse(version, SemVersionStyles.Strict),
            ProjectPath = "/test/project.csproj"
        };
    }

    private static Vulnerability CreateVulnerability(string id, VulnerabilitySeverity severity)
    {
        return new Vulnerability
        {
            Id = id,
            Title = $"Test Vulnerability {id}",
            Description = "Test vulnerability description",
            Severity = severity,
            PackageId = "VulnerablePackage",
            AffectedVersions = new List<SemVersion> { SemVersion.Parse("1.0.0", SemVersionStyles.Strict) },
            PatchedVersions = new List<SemVersion> { SemVersion.Parse("1.1.0", SemVersionStyles.Strict) },
            AdvisoryUrl = new Uri($"https://github.com/advisories/{id}"),
            PublishedAt = DateTime.UtcNow
        };
    }

    #endregion
}