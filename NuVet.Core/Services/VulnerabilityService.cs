using System.Text.Json;
using Microsoft.Extensions.Logging;
using NuVet.Core.Models;
using NuVet.Core.Services;
using Semver;

namespace NuVet.Core.Services.Implementation;

/// <summary>
/// Implementation of IVulnerabilityService that uses GitHub Security Advisories and NuGet vulnerability data
/// </summary>
public class VulnerabilityService : IVulnerabilityService
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<VulnerabilityService> _logger;
    private readonly Dictionary<string, List<Vulnerability>> _cache = new();
    private DateTime _lastCacheUpdate = DateTime.MinValue;
    private readonly TimeSpan _cacheExpiration = TimeSpan.FromHours(24);

    public VulnerabilityService(HttpClient httpClient, ILogger<VulnerabilityService> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
        
        // Set up GitHub API headers
        _httpClient.DefaultRequestHeaders.Add("User-Agent", "NuVet-Scanner/1.0");
        _httpClient.DefaultRequestHeaders.Add("Accept", "application/vnd.github.v3+json");
    }

    public async Task<List<Vulnerability>> GetVulnerabilitiesAsync(string packageId, CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogDebug("Getting vulnerabilities for package {PackageId}", packageId);

            // Check cache first
            if (_cache.TryGetValue(packageId, out var cachedVulns) && 
                DateTime.UtcNow - _lastCacheUpdate < _cacheExpiration)
            {
                _logger.LogDebug("Returning cached vulnerabilities for {PackageId}", packageId);
                return cachedVulns;
            }

            var vulnerabilities = new List<Vulnerability>();

            // Get vulnerabilities from GitHub Security Advisories
            var githubVulns = await GetGitHubSecurityAdvisoriesAsync(packageId, cancellationToken);
            vulnerabilities.AddRange(githubVulns);

            // Get vulnerabilities from NuGet.org (when available)
            var nugetVulns = await GetNuGetVulnerabilitiesAsync(packageId, cancellationToken);
            vulnerabilities.AddRange(nugetVulns);

            // Update cache
            _cache[packageId] = vulnerabilities;
            _lastCacheUpdate = DateTime.UtcNow;

            _logger.LogDebug("Found {Count} vulnerabilities for package {PackageId}", vulnerabilities.Count, packageId);
            return vulnerabilities;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting vulnerabilities for package {PackageId}", packageId);
            return new List<Vulnerability>();
        }
    }

    public async Task<Dictionary<string, List<Vulnerability>>> GetVulnerabilitiesAsync(
        IEnumerable<string> packageIds,
        CancellationToken cancellationToken = default)
    {
        var result = new Dictionary<string, List<Vulnerability>>();
        
        // Process packages in batches to avoid overwhelming the API
        const int batchSize = 10;
        var packages = packageIds.ToList();
        
        for (int i = 0; i < packages.Count; i += batchSize)
        {
            var batch = packages.Skip(i).Take(batchSize);
            var tasks = batch.Select(async packageId =>
            {
                var vulns = await GetVulnerabilitiesAsync(packageId, cancellationToken);
                return new { PackageId = packageId, Vulnerabilities = vulns };
            });

            var batchResults = await Task.WhenAll(tasks);
            foreach (var batchResult in batchResults)
            {
                result[batchResult.PackageId] = batchResult.Vulnerabilities;
            }

            // Small delay between batches to be respectful to APIs
            if (i + batchSize < packages.Count)
            {
                await Task.Delay(100, cancellationToken);
            }
        }

        return result;
    }

    public async Task<List<Vulnerability>> CheckPackageVersionAsync(
        string packageId,
        string version,
        CancellationToken cancellationToken = default)
    {
        var allVulnerabilities = await GetVulnerabilitiesAsync(packageId, cancellationToken);
        var packageVersion = SemVersion.Parse(version, SemVersionStyles.Strict);
        
        return allVulnerabilities.Where(v => v.IsVersionAffected(packageVersion)).ToList();
    }

    public Task<DateTime?> GetLastUpdateAsync(CancellationToken cancellationToken = default)
    {
        // Return the last cache update time
        return Task.FromResult<DateTime?>(_lastCacheUpdate == DateTime.MinValue ? null : _lastCacheUpdate);
    }

    public Task RefreshVulnerabilityDatabaseAsync(CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Refreshing vulnerability database cache");
        
        // Clear the cache to force fresh data on next request
        _cache.Clear();
        _lastCacheUpdate = DateTime.MinValue;
        
        _logger.LogInformation("Vulnerability database cache cleared");
        
        return Task.CompletedTask;
    }

    private async Task<List<Vulnerability>> GetGitHubSecurityAdvisoriesAsync(string packageId, CancellationToken cancellationToken)
    {
        try
        {
            // GitHub Security Advisories API
            var url = $"https://api.github.com/advisories?ecosystem=nuget&affects={packageId}";
            
            _logger.LogDebug("Fetching GitHub Security Advisories for {PackageId}", packageId);
            
            var response = await _httpClient.GetAsync(url, cancellationToken);
            if (!response.IsSuccessStatusCode)
            {
                _logger.LogWarning("GitHub Security Advisories API returned {StatusCode} for {PackageId}", 
                    response.StatusCode, packageId);
                return new List<Vulnerability>();
            }

            var json = await response.Content.ReadAsStringAsync(cancellationToken);
            var advisories = JsonSerializer.Deserialize<GitHubAdvisory[]>(json, new JsonSerializerOptions 
            { 
                PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower 
            });

            if (advisories == null) return new List<Vulnerability>();

            return advisories.Select(advisory => new Vulnerability
            {
                Id = advisory.GhsaId,
                Title = advisory.Summary,
                Description = advisory.Description,
                Severity = MapSeverity(advisory.Severity),
                PackageId = packageId,
                AffectedVersions = ParseVersionRanges(advisory.Vulnerabilities?.FirstOrDefault()?.VulnerableVersionRange),
                PatchedVersions = ParseVersionRanges(advisory.Vulnerabilities?.FirstOrDefault()?.PatchedVersions),
                AdvisoryUrl = new Uri(advisory.HtmlUrl),
                PublishedAt = advisory.PublishedAt,
                UpdatedAt = advisory.UpdatedAt,
                CveIds = advisory.CveId != null ? new List<string> { advisory.CveId } : new List<string>(),
                References = advisory.References?.Select(r => r.Url).ToList() ?? new List<string>()
            }).ToList();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error fetching GitHub Security Advisories for {PackageId}", packageId);
            return new List<Vulnerability>();
        }
    }

    private Task<List<Vulnerability>> GetNuGetVulnerabilitiesAsync(string packageId, CancellationToken cancellationToken)
    {
        try
        {
            // NuGet.org doesn't have a public vulnerability API yet, but this is where we'd implement it
            // When NuGet.org adds vulnerability data to their API, we can fetch it here
            
            _logger.LogDebug("NuGet vulnerability API not yet available for {PackageId}", packageId);
            return Task.FromResult(new List<Vulnerability>());
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error fetching NuGet vulnerabilities for {PackageId}", packageId);
            return Task.FromResult(new List<Vulnerability>());
        }
    }

    private static VulnerabilitySeverity MapSeverity(string? severity)
    {
        return severity?.ToLowerInvariant() switch
        {
            "low" => VulnerabilitySeverity.Low,
            "moderate" => VulnerabilitySeverity.Moderate,
            "high" => VulnerabilitySeverity.High,
            "critical" => VulnerabilitySeverity.Critical,
            _ => VulnerabilitySeverity.Unknown
        };
    }

    private static List<SemVersion> ParseVersionRanges(string? versionRange)
    {
        if (string.IsNullOrWhiteSpace(versionRange))
            return new List<SemVersion>();

        try
        {
            // Simple implementation - in practice, you'd want proper NuGet version range parsing
            // For now, just try to parse as a single version
            if (SemVersion.TryParse(versionRange, SemVersionStyles.Strict, out var version))
            {
                return new List<SemVersion> { version };
            }
        }
        catch
        {
            // Ignore parsing errors
        }

        return new List<SemVersion>();
    }

    // DTOs for GitHub Security Advisories API
    private class GitHubAdvisory
    {
        public string GhsaId { get; set; } = string.Empty;
        public string Summary { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
        public string Severity { get; set; } = string.Empty;
        public string HtmlUrl { get; set; } = string.Empty;
        public DateTime PublishedAt { get; set; }
        public DateTime? UpdatedAt { get; set; }
        public string? CveId { get; set; }
        public GitHubVulnerability[]? Vulnerabilities { get; set; }
        public GitHubReference[]? References { get; set; }
    }

    private class GitHubVulnerability
    {
        public string Package { get; set; } = string.Empty;
        public string VulnerableVersionRange { get; set; } = string.Empty;
        public string PatchedVersions { get; set; } = string.Empty;
    }

    private class GitHubReference
    {
        public string Url { get; set; } = string.Empty;
    }
}