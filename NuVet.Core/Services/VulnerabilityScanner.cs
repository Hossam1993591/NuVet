using Microsoft.Extensions.Logging;
using NuVet.Core.Models;
using NuVet.Core.Services;

namespace NuVet.Core.Services.Implementation;

/// <summary>
/// Implementation of IVulnerabilityScanner that coordinates dependency analysis and vulnerability checking
/// </summary>
public class VulnerabilityScanner : IVulnerabilityScanner
{
    private readonly IDependencyAnalyzer _dependencyAnalyzer;
    private readonly IVulnerabilityService _vulnerabilityService;
    private readonly ILogger<VulnerabilityScanner> _logger;

    public VulnerabilityScanner(
        IDependencyAnalyzer dependencyAnalyzer,
        IVulnerabilityService vulnerabilityService,
        ILogger<VulnerabilityScanner> logger)
    {
        _dependencyAnalyzer = dependencyAnalyzer;
        _vulnerabilityService = vulnerabilityService;
        _logger = logger;
    }

    public async Task<ScanResult> ScanAsync(
        string solutionOrProjectPath,
        ScanOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        var startTime = DateTime.UtcNow;
        options ??= new ScanOptions();
        
        _logger.LogInformation("Starting vulnerability scan for {Path}", solutionOrProjectPath);

        try
        {
            // Step 1: Analyze dependencies
            _logger.LogDebug("Analyzing dependencies...");
            var dependencyGraph = await _dependencyAnalyzer.AnalyzeAsync(solutionOrProjectPath, cancellationToken);
            
            // Step 2: Scan for vulnerabilities
            var scanResult = await ScanDependencyGraphAsync(dependencyGraph, options, cancellationToken);
            
            var duration = DateTime.UtcNow - startTime;
            _logger.LogInformation("Vulnerability scan completed in {Duration}. Found {VulnerablePackages} vulnerable packages",
                duration, scanResult.VulnerablePackages.Count);

            return new ScanResult
            {
                SolutionPath = scanResult.SolutionPath,
                ScanDate = scanResult.ScanDate,
                VulnerablePackages = scanResult.VulnerablePackages,
                ScannedProjects = scanResult.ScannedProjects,
                Summary = scanResult.Summary,
                ScanDuration = duration,
                ScanVersion = scanResult.ScanVersion
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during vulnerability scan of {Path}", solutionOrProjectPath);
            
            return new ScanResult
            {
                SolutionPath = solutionOrProjectPath,
                ScanDate = startTime,
                VulnerablePackages = new List<VulnerablePackage>(),
                ScannedProjects = new List<ProjectInfo>(),
                Summary = new ScanSummary
                {
                    TotalProjects = 0,
                    TotalPackages = 0,
                    VulnerablePackages = 0,
                    CriticalVulnerabilities = 0,
                    HighVulnerabilities = 0,
                    ModerateVulnerabilities = 0,
                    LowVulnerabilities = 0,
                    UnknownVulnerabilities = 0
                },
                ScanDuration = DateTime.UtcNow - startTime
            };
        }
    }

    public async Task<ScanResult> ScanDependencyGraphAsync(
        DependencyGraph dependencyGraph,
        ScanOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        var startTime = DateTime.UtcNow;
        options ??= new ScanOptions();

        _logger.LogInformation("Scanning dependency graph with {PackageCount} packages across {ProjectCount} projects",
            dependencyGraph.AllPackages.Count, dependencyGraph.Projects.Count);

        // Filter packages based on options
        var packagesToScan = FilterPackages(dependencyGraph.AllPackages, options);
        
        // Filter projects if specified
        var projectsToInclude = options.IncludeOnlyProjects.Any() 
            ? dependencyGraph.Projects.Where(p => options.IncludeOnlyProjects.Any(include => 
                p.Path.Contains(include, StringComparison.OrdinalIgnoreCase))).ToList()
            : dependencyGraph.Projects;

        // Scan packages for vulnerabilities
        var vulnerablePackages = await ScanPackagesAsync(packagesToScan, cancellationToken);

        // Filter by minimum severity
        vulnerablePackages = vulnerablePackages
            .Where(vp => vp.HighestSeverity >= options.MinimumSeverity)
            .ToList();

        // Build summary
        var summary = BuildScanSummary(dependencyGraph, vulnerablePackages);

        var scanResult = new ScanResult
        {
            SolutionPath = dependencyGraph.RootPath,
            ScanDate = startTime,
            VulnerablePackages = vulnerablePackages,
            ScannedProjects = projectsToInclude,
            Summary = summary,
            ScanDuration = DateTime.UtcNow - startTime,
            ScanVersion = GetType().Assembly.GetName().Version?.ToString()
        };

        _logger.LogInformation("Scan completed. Found {VulnerableCount} vulnerable packages out of {TotalCount} scanned",
            vulnerablePackages.Count, packagesToScan.Count());

        return scanResult;
    }

    public async Task<List<VulnerablePackage>> ScanPackagesAsync(
        IEnumerable<PackageReference> packages,
        CancellationToken cancellationToken = default)
    {
        var vulnerablePackages = new List<VulnerablePackage>();
        var packageList = packages.ToList();
        
        _logger.LogDebug("Scanning {Count} packages for vulnerabilities", packageList.Count);

        // Group packages by ID to avoid duplicate API calls
        var packageGroups = packageList.GroupBy(p => p.Id, StringComparer.OrdinalIgnoreCase);
        
        foreach (var packageGroup in packageGroups)
        {
            try
            {
                var packageId = packageGroup.Key;
                var packageVersions = packageGroup.ToList();
                
                _logger.LogDebug("Checking vulnerabilities for package {PackageId}", packageId);
                
                // Get all vulnerabilities for this package
                var vulnerabilities = await _vulnerabilityService.GetVulnerabilitiesAsync(packageId, cancellationToken);
                
                if (!vulnerabilities.Any()) continue;

                // Check each version of this package
                foreach (var packageRef in packageVersions)
                {
                    var affectedVulnerabilities = vulnerabilities
                        .Where(v => v.IsVersionAffected(packageRef.Version))
                        .ToList();

                    if (affectedVulnerabilities.Any())
                    {
                        var affectedProjects = packageList
                            .Where(p => p.Id.Equals(packageId, StringComparison.OrdinalIgnoreCase) && 
                                       p.Version.Equals(packageRef.Version))
                            .Select(p => p.ProjectPath)
                            .Distinct()
                            .ToList();

                        var vulnerablePackage = new VulnerablePackage
                        {
                            Package = packageRef,
                            Vulnerabilities = affectedVulnerabilities,
                            AffectedProjects = affectedProjects
                        };

                        vulnerablePackages.Add(vulnerablePackage);
                        
                        _logger.LogWarning("Found {VulnCount} vulnerabilities in {PackageId} {Version} (Severity: {Severity})",
                            affectedVulnerabilities.Count, packageId, packageRef.Version, vulnerablePackage.HighestSeverity);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error scanning package {PackageId} for vulnerabilities", packageGroup.Key);
            }
        }

        return vulnerablePackages;
    }

    private static IEnumerable<PackageReference> FilterPackages(IEnumerable<PackageReference> packages, ScanOptions options)
    {
        var filtered = packages.AsEnumerable();

        // Filter out excluded packages
        if (options.ExcludePackages.Any())
        {
            filtered = filtered.Where(p => !options.ExcludePackages.Any(exclude =>
                p.Id.Contains(exclude, StringComparison.OrdinalIgnoreCase)));
        }

        // Filter by dependency type
        if (!options.IncludeTransitiveDependencies)
        {
            filtered = filtered.Where(p => p.IsDirectDependency);
        }

        return filtered;
    }

    private static ScanSummary BuildScanSummary(DependencyGraph dependencyGraph, List<VulnerablePackage> vulnerablePackages)
    {
        var allVulnerabilities = vulnerablePackages.SelectMany(vp => vp.Vulnerabilities).ToList();
        
        return new ScanSummary
        {
            TotalProjects = dependencyGraph.Projects.Count,
            TotalPackages = dependencyGraph.GetUniquePackages().Count(),
            VulnerablePackages = vulnerablePackages.Count,
            CriticalVulnerabilities = allVulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Critical),
            HighVulnerabilities = allVulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.High),
            ModerateVulnerabilities = allVulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Moderate),
            LowVulnerabilities = allVulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Low),
            UnknownVulnerabilities = allVulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Unknown)
        };
    }
}